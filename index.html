<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Binary Orbit Visualizer with Light Curve</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            /* Black background for space */
            margin: 0;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        /* Container for visualizations, takes full screen */
        #visualizationArea {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background-color: #000000;
            /* Black background */
        }

        /* Container for 3D canvas */
        #canvasContainer {
            flex-grow: 1;
            /* Takes up remaining vertical space */
            min-height: 200px;
            /* Minimum height */
            position: relative;
            /* For positioning canvas inside */
            overflow: hidden;
            /* Clip contents */
            /* Background set by three.js scene */
        }

        #orbitCanvas {
            /* 3D Canvas */
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Light Curve Area */
        #lightCurveContainer {
            height: 180px;
            /* Slightly taller light curve */
            flex-shrink: 0;
            /* Prevent shrinking */
            background-color: #1f2937;
            /* Dark gray background */
            border-top: 1px solid #4b5563;
            /* Lighter gray separator */
            padding: 0.75rem;
            /* p-3 */
            box-sizing: border-box;
            position: relative;
        }

        #lightCurveCanvas {
            /* 2D Canvas */
            display: block;
            width: 100%;
            height: 100%;
            background-color: #374151;
            /* Slightly lighter dark gray */
            border-radius: 0.25rem;
            /* rounded-sm */
        }

        /* Floating Controls Container */
        #controlsContainer {
            position: absolute;
            top: 1rem;
            /* 16px */
            right: 1rem;
            /* 16px */
            z-index: 10;
            /* Ensure it's above the canvas */
            width: 20rem;
            /* Fixed width */
            max-height: calc(100vh - 2rem);
            /* Limit height */
            background-color: rgba(31, 41, 55, 0.85);
            /* Dark gray semi-transparent background */
            backdrop-filter: blur(5px);
            /* Optional blur effect */
            -webkit-backdrop-filter: blur(5px);
            /* Safari */
            padding: 1rem;
            border-radius: 0.5rem;
            /* rounded-lg */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3), 0 2px 4px -2px rgb(0 0 0 / 0.2);
            /* Darker shadow */
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            /* gap-3 */
            overflow: hidden;
            /* Hide content when collapsed */
            transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
            /* Smooth collapse */
            color: #e5e7eb;
            /* Light gray text */
        }

        #controlsContainer.collapsed {
            max-height: 40px;
            /* Height when collapsed (adjust based on button/title) */
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            overflow: hidden;
        }

        #controlsContent {
            /* Content that gets hidden */
            overflow-y: auto;
            /* Allow scrolling if content overflows */
            max-height: calc(100vh - 6rem);
            /* Adjust based on container padding/button */
            transition: opacity 0.3s ease-in-out;
        }

        #controlsContainer.collapsed #controlsContent {
            opacity: 0;
            max-height: 0;
            pointer-events: none;
            /* Prevent interaction when hidden */
        }

        #collapseButton {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #9ca3af;
            /* gray-400 */
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }

        #collapseButton:hover {
            color: #e5e7eb;
            /* gray-200 */
        }

        /* Responsive width for controls on smaller screens */
        @media (max-width: 767px) {
            #controlsContainer {
                width: calc(100vw - 2rem);
                /* Almost full width */
                max-width: 20rem;
                /* But not wider than 20rem */
                right: 50%;
                transform: translateX(50%);
                /* Center horizontally */
            }
        }


        /* Style sliders */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #4b5563;
            border-radius: 3px;
            /* Darker track */
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            /* Lighter blue thumb */
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .control-label {
            min-width: 140px;
            flex-shrink: 0;
            font-size: 0.8rem;
            color: #d1d5db;
            /* Lighter gray text */
        }

        .value-display {
            min-width: 45px;
            font-weight: 500;
            text-align: right;
            font-size: 0.8rem;
            color: #e5e7eb;
            /* Light gray text */
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            /* gap-2 */
        }

        h2 {
            color: #f3f4f6;
            /* Lighter title */
        }
    </style>
</head>

<body>
    <div id="visualizationArea">
        <div id="canvasContainer">
            <canvas id="orbitCanvas"></canvas>
        </div>
        <div id="lightCurveContainer">
            <canvas id="lightCurveCanvas"></canvas>
        </div>
    </div>

    <div id="controlsContainer">
        <button id="collapseButton" title="Toggle Controls">☰</button>
        <h2 class="text-base font-semibold mb-1 text-gray-200">Orbital Parameters</h2>
        <div id="controlsContent">
            <div class="control-row">
                <label for="eccentricity" class="control-label">Eccentricity (e):</label>
                <input type="range" id="eccentricity" name="eccentricity" min="0" max="0.95" step="0.01" value="0.5"
                    class="flex-grow">
                <span id="eccentricityValue" class="value-display">0.50</span>
            </div>
            <div class="control-row">
                <label for="omega" class="control-label">Arg. of Peri. (ω):</label>
                <input type="range" id="omega" name="omega" min="0" max="360" step="1" value="45" class="flex-grow">
                <span id="omegaValue" class="value-display">45°</span>
            </div>
            <div class="control-row">
                <label for="inclination" class="control-label">Inclination (i):</label>
                <input type="range" id="inclination" name="inclination" min="0" max="180" step="1" value="90"
                    class="flex-grow"> <span id="inclinationValue" class="value-display">90°</span>
            </div>
            <div class="control-row">
                <label for="Omega" class="control-label">Long. Asc. Node (Ω):</label>
                <input type="range" id="Omega" name="Omega" min="0" max="360" step="1" value="60" class="flex-grow">
                <span id="OmegaValue" class="value-display">60°</span>
            </div>
            <div class="control-row">
                <label for="massRatio" class="control-label">Mass Ratio (m2/m1):</label>
                <input type="range" id="massRatio" name="massRatio" min="0.1" max="10" step="0.1" value="0.5"
                    class="flex-grow">
                <span id="massRatioValue" class="value-display">0.5</span>
            </div>
            <div class="control-row">
                <label for="radiusRatio" class="control-label">Radius Ratio (r2/r1):</label>
                <input type="range" id="radiusRatio" name="radiusRatio" min="0.1" max="10" step="0.1" value="0.7"
                    class="flex-grow">
                <span id="radiusRatioValue" class="value-display">0.7</span>
            </div>
            <div class="control-row">
                <label for="period" class="control-label">Period Factor:</label>
                <input type="range" id="period" name="period" min="0.5" max="5" step="0.1" value="1" class="flex-grow">
                <span id="periodValue" class="value-display">1.0</span>
            </div>
            <div class="control-row">
                <label for="lcPointsSlider" class="control-label">LC Sampling:</label>
                <input type="range" id="lcPointsSlider" name="lcPointsSlider" min="50" max="1000" step="10" value="500"
                    class="flex-grow">
                <span id="lcPointsValue" class="value-display">500</span>
            </div>
            <div class="control-row mt-2">
                <span class="control-label">Semi-major Axis (a):</span>
                <span class="value-display">Fixed Scale</span>
            </div>
            <div class="mt-2">
                <button id="pauseResumeButton"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-2 rounded text-sm transition duration-150 ease-in-out">
                    Pause Animation
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const orbitCanvas = document.getElementById('orbitCanvas');
        const lightCurveCanvas = document.getElementById('lightCurveCanvas');
        const controlsContainer = document.getElementById('controlsContainer');
        const collapseButton = document.getElementById('collapseButton');
        const eccentricitySlider = document.getElementById('eccentricity');
        const omegaSlider = document.getElementById('omega');
        const inclinationSlider = document.getElementById('inclination');
        const OmegaSlider = document.getElementById('Omega');
        const massRatioSlider = document.getElementById('massRatio');
        const radiusRatioSlider = document.getElementById('radiusRatio');
        const periodSlider = document.getElementById('period');
        const lcPointsSlider = document.getElementById('lcPointsSlider');
        const eccentricityValue = document.getElementById('eccentricityValue');
        const omegaValue = document.getElementById('omegaValue');
        const inclinationValue = document.getElementById('inclinationValue');
        const OmegaValue = document.getElementById('OmegaValue');
        const massRatioValue = document.getElementById('massRatioValue');
        const radiusRatioValue = document.getElementById('radiusRatioValue');
        const periodValue = document.getElementById('periodValue');
        const lcPointsValue = document.getElementById('lcPointsValue');
        const pauseResumeButton = document.getElementById('pauseResumeButton');

        // --- Scene Setup ---
        let scene, camera, renderer, controls, composer, bloomPass;
        let primaryStar, secondaryStar, starField;
        let primaryOrbitTube, secondaryOrbitTube;
        let axesHelper;
        let referenceDirectionLine, lineOfNodesLine, periastronDirectionLine;
        const lineLength = 7;

        // --- Light Curve Setup ---
        let lcCtx;
        let lightCurveData = [];
        let lcPoints = parseInt(lcPointsSlider.value);
        let currentPhase = 0;
        let currentFlux = 1.0;
        const basePeriod = 20;

        const starScaleFactor = 0.05;
        const orbitTubeSegments = 128;
        const orbitTubeRadiusSegments = 8;
        const orbitPoints = 200;

        // --- Orbital Parameters ---
        let eccentricity = parseFloat(eccentricitySlider.value);
        let omegaRad = parseFloat(omegaSlider.value) * Math.PI / 180;
        let inclinationRad = parseFloat(inclinationSlider.value) * Math.PI / 180;
        let OmegaRad = parseFloat(OmegaSlider.value) * Math.PI / 180;
        let massRatio = parseFloat(massRatioSlider.value);
        let radiusRatio = parseFloat(radiusRatioSlider.value);
        let periodFactor = parseFloat(periodSlider.value);
        const semiMajorAxisRelative = 5;
        let radius1 = 0, radius2 = 0;
        const totalRadiusScale = 0.15;

        // --- Animation State ---
        let animationFrameId = null;
        let currentTime = 0;
        let lastTimestamp = 0;
        let isPaused = false;

        // --- Constants ---
        const ORIGIN = new THREE.Vector3(0, 0, 0);
        const X_AXIS = new THREE.Vector3(1, 0, 0);
        const TWO_PI = 2 * Math.PI;
        const ORBIT_TUBE_RADIUS = 0.03;
        const LC_LINE_WIDTH = 2.0;
        const STARFIELD_RADIUS = 100;
        const STARFIELD_STARS = 5000;

        /**
         * Solves Kepler's Equation.
         */
        function solveKepler(M, e, maxIter = 10, tolerance = 1e-7) {
            let E = (e < 0.8) ? M : Math.PI;
            for (let i = 0; i < maxIter; i++) {
                const f = E - e * Math.sin(E) - M;
                const fPrime = 1 - e * Math.cos(E);
                const deltaE = f / fPrime;
                E -= deltaE;
                if (Math.abs(deltaE) < tolerance) break;
            }
            return E;
        }

        /**
         * Calculates relative 3D position.
         */
        function calculateRelativePosition3D(a, e, i, omega, Omega, M) {
            const E = solveKepler(M, e);
            const x_orb = a * (Math.cos(E) - e);
            const y_orb = a * Math.sqrt(1 - e * e) * Math.sin(E);
            const cos_omega = Math.cos(omega); const sin_omega = Math.sin(omega);
            const cos_Omega = Math.cos(Omega); const sin_Omega = Math.sin(Omega);
            const cos_i = Math.cos(i); const sin_i = Math.sin(i);
            const Px = cos_omega * cos_Omega - sin_omega * sin_Omega * cos_i;
            const Py = cos_omega * sin_Omega + sin_omega * cos_Omega * cos_i;
            const Pz = sin_omega * sin_i;
            const Qx = -sin_omega * cos_Omega - cos_omega * sin_Omega * cos_i;
            const Qy = -sin_omega * sin_Omega + cos_omega * cos_Omega * cos_i;
            const Qz = cos_omega * sin_i;
            const position = new THREE.Vector3(x_orb * Px + y_orb * Qx, x_orb * Py + y_orb * Qy, x_orb * Pz + y_orb * Qz);
            return position;
        }

        /**
         * Calculates barycentric positions.
         */
        function calculateBarycentricPositions(relativePos, q) {
            const factor1 = -q / (1 + q);
            const factor2 = 1 / (1 + q);
            const pos1 = relativePos.clone().multiplyScalar(factor1);
            const pos2 = relativePos.clone().multiplyScalar(factor2);
            return { pos1, pos2 };
        }

        /**
         * Calculates star radii based on ratio and scale.
         */
        function calculateStarRadii() {
            const totalRadius = totalRadiusScale * semiMajorAxisRelative;
            radius1 = totalRadius / (1 + radiusRatio);
            radius2 = radiusRatio * radius1;
        }

        /**
         * Calculates the approximate flux based on projected positions and radii.
         */
        function calculateFlux(pos1, pos2, r1, r2) {
            const dx = pos2.x - pos1.x;
            const dy = pos2.y - pos1.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            const rSum = r1 + r2;
            const rDiff = Math.abs(r1 - r2);
            const area1 = Math.PI * r1 * r1;
            const area2 = Math.PI * r2 * r2;
            const totalArea = area1 + area2;
            if (r1 <= 0 || r2 <= 0 || totalArea <= 0) return 1.0;
            if (d >= rSum) return 1.0;
            if (d <= rDiff) {
                const smallerArea = Math.min(area1, area2);
                return 1.0 - smallerArea / totalArea;
            }
            const d2 = d * d; const r1_2 = r1 * r1; const r2_2 = r2 * r2;
            const acosArg1 = (d2 + r1_2 - r2_2) / (2 * d * r1);
            const acosArg2 = (d2 + r2_2 - r1_2) / (2 * d * r2);
            const safeAcosArg1 = Math.max(-1, Math.min(1, acosArg1));
            const safeAcosArg2 = Math.max(-1, Math.min(1, acosArg2));
            const angle1 = Math.acos(safeAcosArg1);
            const angle2 = Math.acos(safeAcosArg2);
            const term1 = r1_2 * angle1; const term2 = r2_2 * angle2;
            const term3 = 0.5 * Math.sqrt(Math.max(0, (-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2)));
            const overlapArea = term1 + term2 - term3;
            if (isNaN(overlapArea) || overlapArea <= 0) return 1.0;
            return Math.max(0, 1.0 - overlapArea / totalArea);
        }


        /**
         * Calculates the full light curve data for one orbit, sampling by time.
         */
        function updateFullLightCurve() {
            lightCurveData = [];
            calculateStarRadii();
            const effectivePeriod = basePeriod / Math.max(periodFactor, 0.01);
            const numPoints = lcPoints; // Use current value

            for (let i = 0; i <= numPoints; i++) {
                const time = (i / numPoints) * effectivePeriod;
                const phase = (time / effectivePeriod) % 1.0;
                const M = (TWO_PI * time / effectivePeriod) % TWO_PI;

                const relativePos = calculateRelativePosition3D(semiMajorAxisRelative, eccentricity, inclinationRad, omegaRad, OmegaRad, M);
                const { pos1, pos2 } = calculateBarycentricPositions(relativePos, massRatio);
                const flux = calculateFlux(pos1, pos2, radius1, radius2);
                lightCurveData.push({ phase: phase, flux: flux });
            }
            lightCurveData.sort((a, b) => a.phase - b.phase);
        }

        /**
         * Draws the light curve on the 2D canvas with grid lines.
         */
        function drawLightCurve() {
            if (!lcCtx || !lightCurveData || lightCurveData.length === 0) return;
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = lightCurveCanvas.clientWidth * dpr;
            const canvasHeight = lightCurveCanvas.clientHeight * dpr;
            if (canvasWidth <= 0 || canvasHeight <= 0) return;
            if (lightCurveCanvas.width !== canvasWidth || lightCurveCanvas.height !== canvasHeight) {
                lightCurveCanvas.width = canvasWidth;
                lightCurveCanvas.height = canvasHeight;
            }
            const padding = 20 * dpr;
            const plotWidth = canvasWidth - 2 * padding;
            const plotHeight = canvasHeight - 2 * padding;
            if (plotWidth <= 0 || plotHeight <= 0) return;

            lcCtx.setTransform(1, 0, 0, 1, 0, 0);
            lcCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            // Background is set by CSS now

            // --- Calculate Y-axis scale ---
            let minFlux = 1.0; lightCurveData.forEach(p => { minFlux = Math.min(minFlux, p.flux); });
            const fluxRange = 1.0 - minFlux; const yMin = Math.max(0, minFlux - fluxRange * 0.1); const yMax = 1.0 + fluxRange * 0.05; const yRange = Math.max(yMax - yMin, 1e-6);
            const getYPos = (fluxValue) => padding + plotHeight * (1.0 - (fluxValue - yMin) / yRange);

            // --- Draw Grid Lines ---
            lcCtx.strokeStyle = "#4b5563"; // Medium-dark gray grid
            lcCtx.lineWidth = 0.5 * dpr;
            // Vertical lines (Phase)
            for (let phaseTick = 0.1; phaseTick < 1.0; phaseTick += 0.1) {
                const x = padding + phaseTick * plotWidth;
                lcCtx.beginPath();
                lcCtx.moveTo(x, padding);
                lcCtx.lineTo(x, canvasHeight - padding);
                lcCtx.stroke();
            }
            // Horizontal lines (Flux) - Draw based on calculated range
            const numFluxLines = 5;
            for (let i = 0; i <= numFluxLines; i++) {
                const fluxVal = yMin + (yRange * i / numFluxLines);
                // Don't draw lines too close to 1.0 or minFlux if labels are there
                if (Math.abs(fluxVal - 1.0) > 0.01 && Math.abs(fluxVal - minFlux) > 0.01) {
                    const y = getYPos(fluxVal);
                    lcCtx.beginPath();
                    lcCtx.moveTo(padding, y);
                    lcCtx.lineTo(canvasWidth - padding, y);
                    lcCtx.stroke();
                }
            }


            // --- Draw Axes ---
            lcCtx.strokeStyle = "#9ca3af"; // Lighter gray axes
            lcCtx.lineWidth = 1 * dpr;
            lcCtx.beginPath(); lcCtx.moveTo(padding, padding); lcCtx.lineTo(padding, canvasHeight - padding); lcCtx.lineTo(canvasWidth - padding, canvasHeight - padding); lcCtx.stroke();

            // --- Draw Axis Labels/Ticks ---
            lcCtx.fillStyle = "#d1d5db"; // Light gray text
            lcCtx.font = `${10 * dpr}px Inter`;
            lcCtx.textAlign = "center"; lcCtx.textBaseline = "top";
            lcCtx.fillText("0.0", padding, canvasHeight - padding + 4 * dpr); lcCtx.fillText("0.5", padding + plotWidth / 2, canvasHeight - padding + 4 * dpr); lcCtx.fillText("1.0", padding + plotWidth, canvasHeight - padding + 4 * dpr); lcCtx.fillText("Phase", padding + plotWidth / 2, canvasHeight - padding + 12 * dpr);
            lcCtx.textAlign = "right"; lcCtx.textBaseline = "middle";
            lcCtx.fillText("1.0", padding - 4 * dpr, getYPos(1.0)); const minFluxYPos = getYPos(minFlux); lcCtx.fillText(minFlux.toFixed(2), padding - 4 * dpr, minFluxYPos);
            lcCtx.save(); lcCtx.translate(padding - 15 * dpr, canvasHeight / 2); lcCtx.rotate(-Math.PI / 2); lcCtx.textAlign = "center"; lcCtx.fillText("Norm. Flux", 0, 0); lcCtx.restore();

            // --- Draw Full Light Curve ---
            lcCtx.strokeStyle = "#60a5fa"; // Lighter blue
            lcCtx.lineWidth = LC_LINE_WIDTH * dpr;
            lcCtx.beginPath();
            lightCurveData.forEach((point, index) => {
                const x = padding + point.phase * plotWidth; const y = getYPos(point.flux);
                if (index === 0) { lcCtx.moveTo(x, y); } else { lcCtx.lineTo(x, y); }
            });
            lcCtx.stroke();

            // --- Draw Current Phase Marker ---
            const currentX = padding + currentPhase * plotWidth; const currentY = getYPos(currentFlux);
            lcCtx.fillStyle = "#fcd34d"; // Lighter amber
            lcCtx.beginPath(); lcCtx.arc(currentX, currentY, 3 * dpr, 0, TWO_PI); lcCtx.fill();
        }

        /**
         * Creates or updates the orbit lines using TubeGeometry.
         */
        function updateOrbitLines() {
            const primaryPoints = []; const secondaryPoints = [];
            for (let step = 0; step <= orbitPoints; step++) {
                const M_orbit = (step / orbitPoints) * TWO_PI;
                const relativePos = calculateRelativePosition3D(semiMajorAxisRelative, eccentricity, inclinationRad, omegaRad, OmegaRad, M_orbit);
                const { pos1, pos2 } = calculateBarycentricPositions(relativePos, massRatio);
                primaryPoints.push(pos1); secondaryPoints.push(pos2);
            }
            const primaryCurve = new THREE.CatmullRomCurve3(primaryPoints, true);
            const secondaryCurve = new THREE.CatmullRomCurve3(secondaryPoints, true);

            // --- Primary Orbit Tube ---
            if (!primaryOrbitTube) {
                const tubeGeometry = new THREE.TubeGeometry(primaryCurve, orbitTubeSegments, ORBIT_TUBE_RADIUS, orbitTubeRadiusSegments, true);
                const tubeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf59e0b, metalness: 0.1, roughness: 0.8,
                    transparent: true, opacity: 0.7
                });
                primaryOrbitTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                scene.add(primaryOrbitTube);
            } else {
                const newTubeGeometry = new THREE.TubeGeometry(primaryCurve, orbitTubeSegments, ORBIT_TUBE_RADIUS, orbitTubeRadiusSegments, true);
                primaryOrbitTube.geometry.dispose();
                primaryOrbitTube.geometry = newTubeGeometry;
                primaryOrbitTube.material.transparent = true;
                primaryOrbitTube.material.opacity = 0.7;
            }

            // --- Secondary Orbit Tube ---
            if (!secondaryOrbitTube) {
                const tubeGeometry = new THREE.TubeGeometry(secondaryCurve, orbitTubeSegments, ORBIT_TUBE_RADIUS, orbitTubeRadiusSegments, true);
                const tubeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x3b82f6, metalness: 0.1, roughness: 0.8,
                    transparent: true, opacity: 0.7
                });
                secondaryOrbitTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                scene.add(secondaryOrbitTube);
            } else {
                const newTubeGeometry = new THREE.TubeGeometry(secondaryCurve, orbitTubeSegments, ORBIT_TUBE_RADIUS, orbitTubeRadiusSegments, true);
                secondaryOrbitTube.geometry.dispose();
                secondaryOrbitTube.geometry = newTubeGeometry;
                secondaryOrbitTube.material.transparent = true;
                secondaryOrbitTube.material.opacity = 0.7;
            }
        }


        /**
         * Updates star sizes based on mass ratio (for 3D view).
         */
        function updateStarSizes() {
            const m1 = 1; const m2 = massRatio; const totalMass = m1 + m2;
            const baseSphereRadius = semiMajorAxisRelative * starScaleFactor;
            const safeTotalMass = Math.max(totalMass, 1e-6);
            const scale1 = Math.cbrt(m1 / safeTotalMass); const scale2 = Math.cbrt(m2 / safeTotalMass);
            const minScaleFactor = 0.4; const visualScaleUp = 1.5;
            const radius1_3d = baseSphereRadius * Math.max(minScaleFactor, scale1) * visualScaleUp;
            const radius2_3d = baseSphereRadius * Math.max(minScaleFactor, scale2) * visualScaleUp;
            if (primaryStar) primaryStar.scale.setScalar(radius1_3d / baseSphereRadius);
            if (secondaryStar) secondaryStar.scale.setScalar(radius2_3d / baseSphereRadius);
        }

        /**
         * Creates or updates the geometric visualization elements (lines only).
         */
        function updateGeometricElements() {
            const ascNodeDir = new THREE.Vector3(Math.cos(OmegaRad), Math.sin(OmegaRad), 0).normalize();
            const periastronRelativePos = calculateRelativePosition3D(semiMajorAxisRelative, eccentricity, inclinationRad, omegaRad, OmegaRad, 0);
            const { pos2: periPos2 } = calculateBarycentricPositions(periastronRelativePos, massRatio);
            // Ensure periPos2 is a valid vector before normalizing
            const periastronDir = (periPos2 && periPos2.lengthSq() > 1e-9) ? periPos2.clone().normalize() : new THREE.Vector3(1, 0, 0); // Default to X if calculation fails

            // Update Reference Direction Line
            const refEndPoint = X_AXIS.clone().multiplyScalar(lineLength);
            if (!referenceDirectionLine) { const g = new THREE.BufferGeometry().setFromPoints([ORIGIN, refEndPoint]); const m = new THREE.LineBasicMaterial({ color: 0xaaaaaa }); referenceDirectionLine = new THREE.Line(g, m); scene.add(referenceDirectionLine); } // Lighter gray
            else { referenceDirectionLine.geometry.setFromPoints([ORIGIN, refEndPoint]); referenceDirectionLine.geometry.attributes.position.needsUpdate = true; }

            // Update Line of Nodes
            const nodeEndPoint1 = ascNodeDir.clone().multiplyScalar(lineLength); const nodeEndPoint2 = ascNodeDir.clone().multiplyScalar(-lineLength);
            if (!lineOfNodesLine) { const g = new THREE.BufferGeometry().setFromPoints([nodeEndPoint2, nodeEndPoint1]); const m = new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 2 }); lineOfNodesLine = new THREE.Line(g, m); scene.add(lineOfNodesLine); } // Emerald green
            else { lineOfNodesLine.geometry.setFromPoints([nodeEndPoint2, nodeEndPoint1]); lineOfNodesLine.geometry.attributes.position.needsUpdate = true; }

            // Update Periastron Direction Line
            const periLineEndPoint = periastronDir.clone().multiplyScalar(lineLength * 0.9);
            if (!periastronDirectionLine) { const g = new THREE.BufferGeometry().setFromPoints([ORIGIN, periLineEndPoint]); const m = new THREE.LineBasicMaterial({ color: 0xf87171 }); periastronDirectionLine = new THREE.Line(g, m); scene.add(periastronDirectionLine); } // Lighter red
            else { periastronDirectionLine.geometry.setFromPoints([ORIGIN, periLineEndPoint]); periastronDirectionLine.geometry.attributes.position.needsUpdate = true; }

            // Markers are removed.
        }

        /**
         * Creates the starfield background.
         */
        function createStarfield() {
            const starVertices = [];
            for (let i = 0; i < STARFIELD_STARS; i++) {
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u; // Azimuthal angle
                const phi = Math.acos(2 * v - 1); // Polar angle (from +Z)
                const r = STARFIELD_RADIUS * (0.8 + Math.random() * 0.2); // Add some depth variation

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.15,
                sizeAttenuation: true
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }


        /**
         * Initializes the 3D scene, camera, renderer, controls, and objects.
         */
        function init() {
            try {
                // --- Renderers ---
                renderer = new THREE.WebGLRenderer({ canvas: orbitCanvas, antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.toneMapping = THREE.ReinhardToneMapping;

                // --- Light Curve Context ---
                lcCtx = lightCurveCanvas.getContext('2d');

                // --- Scene, Camera, Lights ---
                scene = new THREE.Scene();

                const initialWidth = orbitCanvas.clientWidth || window.innerWidth;
                const initialHeight = orbitCanvas.clientHeight || window.innerHeight;
                const aspect = initialWidth / initialHeight;
                camera = new THREE.PerspectiveCamera(50, aspect, 0.1, STARFIELD_RADIUS * 1.5);
                camera.position.set(0, semiMajorAxisRelative * 1.5, semiMajorAxisRelative * 3);
                camera.lookAt(ORIGIN);
                const ambientLight = new THREE.AmbientLight(0x666666); scene.add(ambientLight);
                const pointLight = new THREE.PointLight(0xffffff, 0.8, 0, 2); camera.add(pointLight); scene.add(camera);

                // --- Controls ---
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false;
                controls.minDistance = semiMajorAxisRelative * 0.5; controls.maxDistance = semiMajorAxisRelative * 15;
                controls.target.set(0, 0, 0); controls.update();

                // --- Stars ---
                const sphereGeometry = new THREE.SphereGeometry(semiMajorAxisRelative * starScaleFactor, 32, 16);
                const primaryMaterial = new THREE.MeshStandardMaterial({ color: 0xf59e0b, roughness: 0.8, metalness: 0.1, emissive: 0x442200 });
                primaryStar = new THREE.Mesh(sphereGeometry, primaryMaterial); scene.add(primaryStar);
                const secondaryMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.8, metalness: 0.1, emissive: 0x001133 });
                secondaryStar = new THREE.Mesh(sphereGeometry, secondaryMaterial); scene.add(secondaryStar);

                // --- Starfield ---
                createStarfield();

                // --- Axes Helper ---
                axesHelper = new THREE.AxesHelper(semiMajorAxisRelative * 0.5);
                scene.add(axesHelper);

                // --- Post-processing (Bloom) ---
                const renderScene = new THREE.RenderPass(scene, camera);
                bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0.2;
                bloomPass.strength = 0.4;
                bloomPass.radius = 0.1;

                composer = new THREE.EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // --- Initial Setup ---
                handleResize();
                updateParameters();

                // --- Event Listeners ---
                window.addEventListener('resize', handleResize);
                eccentricitySlider.addEventListener('input', updateParameters);
                omegaSlider.addEventListener('input', updateParameters);
                inclinationSlider.addEventListener('input', updateParameters);
                OmegaSlider.addEventListener('input', updateParameters);
                massRatioSlider.addEventListener('input', updateParameters);
                radiusRatioSlider.addEventListener('input', updateParameters);
                periodSlider.addEventListener('input', updateParameters);
                lcPointsSlider.addEventListener('input', updateParameters);
                pauseResumeButton.addEventListener('click', togglePause);
                collapseButton.addEventListener('click', () => {
                    controlsContainer.classList.toggle('collapsed');
                    collapseButton.textContent = controlsContainer.classList.contains('collapsed') ? '☰' : '✕';
                });

                // --- Start Animation ---
                lastTimestamp = performance.now();
                animate(lastTimestamp);

            } catch (error) {
                console.error("Initialization failed:", error);
                const visArea = document.getElementById('visualizationArea');
                if (visArea) {
                    visArea.innerHTML = `<p class="text-red-500 p-4">Error initializing visualization: ${error.message}</p>`;
                }
            }
        }

        /**
         * Handles window resize events for both canvases and composer.
         */
        function handleResize() {
            // Resize 3D Canvas & Composer
            const container3D = document.getElementById('canvasContainer');
            const width3D = container3D.clientWidth;
            const height3D = container3D.clientHeight;
            renderer.setSize(width3D, height3D);
            composer.setSize(width3D, height3D);
            camera.aspect = width3D / height3D;
            camera.updateProjectionMatrix();

            drawLightCurve(); // Force redraw immediately on resize
        }

        /**
         * Updates orbital parameters from sliders and redraws everything.
         */
        function updateParameters() {
            // Read values
            eccentricity = parseFloat(eccentricitySlider.value);
            omegaRad = parseFloat(omegaSlider.value) * Math.PI / 180;
            inclinationRad = parseFloat(inclinationSlider.value) * Math.PI / 180;
            OmegaRad = parseFloat(OmegaSlider.value) * Math.PI / 180;
            massRatio = parseFloat(massRatioSlider.value);
            radiusRatio = parseFloat(radiusRatioSlider.value);
            periodFactor = parseFloat(periodSlider.value);
            lcPoints = parseInt(lcPointsSlider.value);

            // Update text displays
            eccentricityValue.textContent = eccentricity.toFixed(2);
            omegaValue.textContent = `${omegaSlider.value}°`;
            inclinationValue.textContent = `${inclinationSlider.value}°`;
            OmegaValue.textContent = `${OmegaSlider.value}°`;
            massRatioValue.textContent = massRatio.toFixed(1);
            radiusRatioValue.textContent = radiusRatio.toFixed(1);
            periodValue.textContent = periodFactor.toFixed(1);
            lcPointsValue.textContent = lcPoints;

            // Update 3D visuals
            updateOrbitLines();
            updateStarSizes();
            updateGeometricElements();

            // Update Light Curve Data
            updateFullLightCurve();

            // Update star positions & current flux if paused
            if (isPaused) {
                updateStarPositions();
            }
            // Ensure light curve is drawn with new data/marker position
            drawLightCurve();
        }

        /**
         * Toggles the pause state of the animation.
         */
        function togglePause() {
            isPaused = !isPaused;
            pauseResumeButton.textContent = isPaused ? 'Resume Animation' : 'Pause Animation';
            pauseResumeButton.classList.toggle('bg-blue-600', !isPaused);
            pauseResumeButton.classList.toggle('hover:bg-blue-700', !isPaused);
            pauseResumeButton.classList.toggle('bg-green-600', isPaused);
            pauseResumeButton.classList.toggle('hover:bg-green-700', isPaused);
            if (!isPaused) {
                lastTimestamp = performance.now();
            }
        }

        /**
        * Updates the positions of the stars and current flux based on the current time.
        */
        function updateStarPositions() {
            const effectivePeriod = basePeriod / Math.max(periodFactor, 0.01);
            currentPhase = (currentTime / effectivePeriod) % 1.0;
            const meanAnomaly = currentPhase * TWO_PI;

            const relativePos = calculateRelativePosition3D(semiMajorAxisRelative, eccentricity, inclinationRad, omegaRad, OmegaRad, meanAnomaly);
            const { pos1, pos2 } = calculateBarycentricPositions(relativePos, massRatio);

            if (primaryStar) primaryStar.position.copy(pos1);
            if (secondaryStar) secondaryStar.position.copy(pos2);

            calculateStarRadii();
            currentFlux = calculateFlux(pos1, pos2, radius1, radius2);
        }

        /**
         * Animation loop.
         */
        function animate(timestamp) {
            animationFrameId = requestAnimationFrame(animate);
            const deltaTime = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            if (!isPaused) {
                currentTime += deltaTime;
                updateStarPositions();
                drawLightCurve();
            }

            controls.update();
            composer.render(); // Render scene with post-processing
        }

        // --- Initialization ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => setTimeout(init, 50));
        } else {
            setTimeout(init, 50);
        }

        // --- Cleanup ---
        window.addEventListener('unload', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if (renderer) renderer.dispose();
            if (scene) {
                scene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    if (object.isMesh || object.isLine || object.isPoints) {
                        scene.remove(object);
                    }
                });
            }
            window.removeEventListener('resize', handleResize);
        });

    </script>

</body>

</html>
